import Head from "next/head";
import { excludedGeneratedPaths } from "../config/excludedGeneratedPaths";
import { fetchAPI } from "../lib/api";
import ErrorComponent from "@/components/elements/ui/ErrorComponent";
import PageComponentBuilderController from "@/components/elements/ui/PageComponentBuilderController";
import { GetStaticProps, InferGetStaticPropsType } from "next";
import { ProductType, SubCategoryType } from "@/types/products";
import { useSubCategories } from "@/context/subCategories";
import { useEffect } from "react";

const GenericPage = ({
  apiBasicPageData,
  page,
  newProducts,
  subcategories,
}: InferGetStaticPropsType<typeof getStaticProps>) => {
  const { setSubCategories, setNewProducts } = useSubCategories();
  useEffect(() => {
    setNewProducts(newProducts);
    setSubCategories(subcategories);
  }, [setSubCategories, subcategories, setNewProducts, newProducts]);
  if (apiBasicPageData) {
    return (
      <>
        <Head>
          <title>{page}</title>
          <meta name="description" content="Generated by create next app" />
          <meta name="viewport" content="width=device-width, initial-scale=1" />
          <link rel="icon" href="/favicon.ico" />
        </Head>
        <div className=" ">
          <PageComponentBuilderController
            page={page}
            pageContent={apiBasicPageData.attributes.page_components}
          />
        </div>
      </>
    );
  }

  return <ErrorComponent message="Error: Page data not found." />;
};

// Gets all the paths for the type basic-pages and generates an object for GetStaticProps
export async function getStaticPaths() {
  const { data: basicPageData } = await fetchAPI("basi-pages");
  const excludedPaths = ["home", "products-range"];
  let generatedPaths = basicPageData
    .map((basicPageDataElement: any) => {
      return {
        params: {
          page: basicPageDataElement.attributes.slug,
          id: basicPageDataElement.id,
        },
      };
    })
    .filter((path: any) => {
      const isPathExist = excludedPaths.find(
        (page) => page === path.params.page
      );
      if (!isPathExist) {
        return path;
      }
    });

  generatedPaths = generatedPaths.filter((generatedPath: any) => {
    if (!excludedGeneratedPaths.includes(generatedPath.params.page)) {
      return generatedPath;
    }
  });

  return {
    paths: generatedPaths,
    fallback: false,
  };
}

// Gets all the data for the type basic-pages and generates an object each page
export const getStaticProps: GetStaticProps<{
  page: string;
  apiBasicPageData: any;
  subcategories: SubCategoryType[];
  newProducts: ProductType[];
}> = async ({ params }) => {
  const { data: basicPageData } = await fetchAPI("basi-pages");

  const generatedPaths = basicPageData.map((basicPageDataElement: any) => {
    return {
      params: {
        page: basicPageDataElement.attributes.slug,
        id: basicPageDataElement.id,
      },
    };
  });

  const getPageIdFromPath = () => {
    const filteredPaths = generatedPaths.filter(
      (path: any) => path.params.page === params?.page
    );

    if (filteredPaths.length > 0) {
      const generatedPathsFiltered = filteredPaths[0].params.id;

      return generatedPathsFiltered;
    }

    return null;
  };
  const { data: subcategories } = await fetchAPI("subcategories", ["products"]);
  const productPopulate = ["image", "products"];
  const { data: productsData } = await fetchAPI("products", productPopulate);

  const products: ProductType[] = productsData.map((product: any) => ({
    ...product.attributes,
    id: product.id,
  }));
  const newProducts = products.filter((product) => product.isNew);
  const pagePopulation = ["deep"];
  const { data } = await fetchAPI(
    `basi-pages/${getPageIdFromPath()}`,
    pagePopulation
  );

  return {
    props: {
      newProducts,
      subcategories: subcategories.map((subcategory: any) => ({
        ...subcategory.attributes,
        id: subcategory.id,
      })),
      apiBasicPageData: data,
      page: params?.page as string,
    },
  };
};

export default GenericPage;
